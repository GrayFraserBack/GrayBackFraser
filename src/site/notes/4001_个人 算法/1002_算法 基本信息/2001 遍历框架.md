---
{"dg-publish":true,"permalink":"/4001/1002/2001/","dgPassFrontmatter":true}
---


# 1 数组遍历框架

```java
/**
 * 遍历数组
 * 
 * 该方法用于遍历给定的整型数组，可以在遍历过程中执行特定操作。
 * 
 * @param arr 需要遍历的整型数组
 */
void traverse(int[] arr) {
    // 数组遍历开始
    for (int i = 0; i < arr.length; i++) {
        // 在此处可以进行数组元素的处理
        // 迭代访问 arr[i]
    }
    // 数组遍历结束
}

// 核心业务场景描述
// 该遍历方法常用于数组的数据处理，如排序、查找、统计等操作。
// 在实际应用中，该方法可以根据具体需求进行扩展，以实现对数组的各种操作。
```

# 2 链表遍历框架

## 2.1 使用循环遍历单链表

```java
/* 基本的单链表节点 */
class ListNode {
    int val; // 节点存储的数据
    ListNode next; // 指向下一个节点的指针
}

/**
 * 使用循环遍历单链表
 * 
 * 该方法通过循环遍历单链表中的每个节点，并可以对每个节点的值进行操作。
 * 
 * @param head 单链表的头节点
 */
void traverse(ListNode head) {
    // 从头节点开始遍历
    for (ListNode p = head; p != null; p = p.next) {
        // 在此处可以进行节点值的处理
        // 迭代访问 p.val
    }
    // 遍历结束
}
```

## 2.2 使用递归遍历单链表

```java
/* 基本的单链表节点 */
class ListNode {
    int val; // 节点存储的数据
    ListNode next; // 指向下一个节点的指针
}


/**
 * 使用递归遍历单链表
 * 
 * 该方法通过递归的方式遍历单链表中的每个节点，并可以对每个节点的值进行操作。
 * 
 * @param head 单链表的头节点
 */
void traverse(ListNode head) {
    if (head == null) return; // 递归结束条件

    // 在此处可以进行节点值的处理
    // 递归访问 head.val

    traverse(head.next); // 递归遍历下一个节点
}

// 核心业务场景描述
// 这两个遍历方法是单链表数据结构中的基本操作，通常用于访问链表中的每个节点，
// 以执行如搜索、排序或者修改等操作。在实际应用中，根据需要选择使用循环还是递归方法来遍历链表。
```

# 3 二叉树遍历框架，典型的非线性递归遍历结构

```java
/**
 * 递归遍历二叉树
 * 
 * 此方法展示了在二叉树遍历过程中的三个关键位置：前序、中序和后序。
 * 前序位置是在递归访问左子树之前的位置，
 * 中序位置是在访问左子树之后，右子树之前的位置，
 * 后序位置是在访问完右子树之后的位置。
 * 
 * @param root 二叉树的根节点
 */
void traverse(TreeNode root) {
    if (root == null) {
        // 当前节点为空，表示到达叶子节点的下一层，递归结束
        return;
    }

    // 前序位置：在这里处理节点意味着进行前序遍历（如打印节点值，处理逻辑等）
    // System.out.println("前序位置：" + root.val);
    traverse(root.left);

    // 中序位置：在左子树和右子树之间处理节点意味着进行中序遍历
    // System.out.println("中序位置：" + root.val);
    traverse(root.right);

    // 后序位置：在这里处理节点意味着进行后序遍历
    // System.out.println("后序位置：" + root.val);
}

// 核心业务场景描述
// 这种遍历方法可以用于多种二叉树操作，例如打印所有节点、
// 计算二叉树的深度、检查二叉树是否平衡等。根据处理节点的位置不同，
// 可以实现前序遍历、中序遍历或后序遍历，适用于不同的业务场景需求。

```

# 4 二叉树框架扩展为 N 叉树的遍历框架

```java
/* 基本的 N 叉树节点 */
class TreeNode {
    int val; // 节点的值
    TreeNode[] children; // 子节点数组，存储当前节点的所有子节点
}

/**
 * 遍历 N 叉树
 * 
 * 此方法通过递归方式遍历 N 叉树的每个节点。从根节点开始，逐个访问每个节点的所有子节点。
 * 
 * @param root N 叉树的根节点
 */
void traverse(TreeNode root) {
    if (root == null) {
        // 当前节点为空，递归结束
        return;
    }

    // 处理当前节点，如打印节点值
    // System.out.println(root.val);

    // 递归遍历当前节点的所有子节点
    for (TreeNode child : root.children) {
        traverse(child); // 递归调用遍历子节点
    }
}

// 核心业务场景描述
// 遍历 N 叉树的方法可以应用于多种业务场景，如在树形结构中搜索特定元素、
// 统计树中的节点数量、或者执行特定的操作处理每个节点的数据。这种递归遍历方式
// 特别适合处理复杂的树形结构，能够有效地访问树中的每个节点。
```

`N` 叉树的遍历又可以扩展为图的遍历，因为图就是好几 `N` 叉棵树的结合体。你说图是可能出现环的？这个很好办，用个布尔数组 `visited` 做标记就行了，这里就不写代码了
